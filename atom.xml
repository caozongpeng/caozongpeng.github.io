<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KyrieCao的个人网站</title>
  
  <subtitle>KyrieCao</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caozongpeng.github.io/"/>
  <updated>2019-02-20T15:40:26.832Z</updated>
  <id>https://caozongpeng.github.io/</id>
  
  <author>
    <name>KyrieCao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最最最常见的Java面试题总结(二)</title>
    <link href="https://caozongpeng.github.io/2019/02/21/%E6%9C%80%E6%9C%80%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E4%BA%8C/"/>
    <id>https://caozongpeng.github.io/2019/02/21/最最最常见的Java面试题总结-二/</id>
    <published>2019-02-21T14:00:24.000Z</published>
    <updated>2019-02-20T15:40:26.832Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章回顾：<a href="https://caozongpeng.github.io/2019/02/20/%E6%9C%80%E6%9C%80%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E4%B8%80/">最最最常见的Java面试题总结(一)</a><br><img src="images/java/java-logo.jpg" alt="mysql"><br><a id="more"></a></p><h3 id="一、String-和-StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"><a href="#一、String-和-StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="一、String 和 StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"></a>一、String 和 StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h3><h4 id="String-和-StringBuffer、StringBuilder的区别"><a href="#String-和-StringBuffer、StringBuilder的区别" class="headerlink" title="String 和 StringBuffer、StringBuilder的区别"></a>String 和 StringBuffer、StringBuilder的区别</h4><p><strong>可变性</strong><br><code>String</code> 类中使用 <code>final</code> 关键字字符数组保存字符串，<code>private final char value[]</code> ,所以 <code>String</code> 对象是不可变的。而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串 <code>char[] value</code> 但是没有用 <code>final</code> 关键字修饰， 所以这两种对象都是可变的。</p><p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，可以自行查阅源码。<br>AbstractStringBuilder.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>线程安全性</strong><br><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。 <code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 <code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong><br>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<br><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10% ~ 15% 左右的性能提升，但即要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong><br>1、操作海量的数据 = <code>String</code><br>2、单线程操作字符串缓冲区下操作大量数据 = <code>StringBuilder</code><br>3、多线程操作字符串缓冲区下操作大量数据 = <code>StringBuffer</code></p><h4 id="String-为什么是不可变的吗？"><a href="#String-为什么是不可变的吗？" class="headerlink" title="String 为什么是不可变的吗？"></a>String 为什么是不可变的吗？</h4><p>简单来说就是 <code>String</code> 类利用了 <code>final</code> 修饰的 <code>char</code> 类型数组存储字符，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure></p><h4 id="String-真的是不可变的吗？"><a href="#String-真的是不可变的吗？" class="headerlink" title="String 真的是不可变的吗？"></a>String 真的是不可变的吗？</h4><p><strong>String不可变但不代表引用不可以变</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Hello"</span>;</span><br><span class="line">str = str + <span class="string">" World"</span>;</span><br><span class="line">System.out.println(<span class="string">"str="</span> + str);</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=Hello World</span><br></pre></td></tr></table></figure></p><p>实际上，原来 <code>String</code> 的内容是不变的，只是str由原来指向 <code>Hello</code> 的内存地址转为指向 <code>Hello World</code> 的内存地址而已，也就是说多开辟了一块内存区域给 <code>Hello World</code> 字符串。</p><p><strong>通过反射是可以修改所谓的 不可变 对象</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br></pre></td></tr></table></figure></p><p>用反射可以访问私有成员，然后反射出 <code>String</code> 对象中的 <code>value</code> 属性，进而改变通过获得的 <code>value</code> 引用改变数组的结构。但是一般我们不会这么做。知道有这个东西就可以了。</p><h3 id="什么是反射机制？反射机制的应用场景有哪些？"><a href="#什么是反射机制？反射机制的应用场景有哪些？" class="headerlink" title="什么是反射机制？反射机制的应用场景有哪些？"></a>什么是反射机制？反射机制的应用场景有哪些？</h3><h4 id="反射机制介绍"><a href="#反射机制介绍" class="headerlink" title="反射机制介绍"></a>反射机制介绍</h4><p><code>JAVA</code> 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为 <code>JAVA</code> 语言的反射机制。</p><h4 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h4><ul><li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong>运行时确定类型，绑定对象</li></ul><h4 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h4><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 性能瓶颈，反射相当于一系列解释操作，通知 <code>JVM</code> 要做的事情，性能比直接的 <code>JAVA</code> 代码要慢很多。</li></ul><h4 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h4><p>反射是框架设计的灵魂</p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码，动态代理设计模式也采用了反射机制，还有我们日常使用的 <code>Spring</code>、<code>Hibernate</code> 等框架也大量使用到了反射机制。</p><p>举例：①我们在使用 <code>JDBC</code> 连接数据库时使用 <code>Class.forName()</code> 通过反射加载数据库的驱动程序。② <code>Spring</code> 框架也用到很多反射机制，最经典的就是 <code>XML</code> 的配置模式， <code>Spring</code> 通过 <code>XML</code> 配置模式装载 <code>Bean</code> 的过程：1)将程序内所有 <code>XML</code> 或 <code>Properties</code> 配置文件加载入内存中。2)<code>JAVA</code> 类里面解析 <code>XML</code> 或 <code>Properties</code> 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息，3)使用反射机制，根据这个字符串获得某个类的 <code>Class</code> 实例，4)动态配置实例的属性。<br><strong>推荐阅读：</strong></p><ul><li><a href="https://segmentfault.com/a/1190000010162647?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Reflection：Java反射机制的应用场景</a></li><li><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">Java基础之—反射（非常重要）</a></li></ul><h3 id="什么是-JDK？-什么是-JRE？-什么是-JVM？三者之间的联系与区别"><a href="#什么是-JDK？-什么是-JRE？-什么是-JVM？三者之间的联系与区别" class="headerlink" title="什么是 JDK？ 什么是 JRE？ 什么是 JVM？三者之间的联系与区别"></a>什么是 JDK？ 什么是 JRE？ 什么是 JVM？三者之间的联系与区别</h3><p>这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。</p><p><strong>JDK：</strong>顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p><p><strong>JRE：</strong> 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p><p><strong>JVM：</strong> 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。</p><h4 id="区别与联系："><a href="#区别与联系：" class="headerlink" title="区别与联系："></a>区别与联系：</h4><p>1、JDK用于开发，JRE用于运行JAVA程序。<br>2、JDK和JRE中包含JVM。<br>3、JVM是Java编程语言的核心并且具有平台独立性。</p><h3 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h3><p><strong>先看下Java中的编译器和解释器：</strong><br>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由包解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种虚拟机理解的代码叫做 字节码 （即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条执行的字节码发送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就解释了Java的编译与解释并存的特点。</p><p>Java源代码 ——&gt; 编译器 ——&gt; Jvm可执行的Java字节码（即虚拟指令）——&gt; Jvm ——&gt; Jvm中解释器 ——&gt; 机器可执行的二进制机器码 ——&gt; 程序运行。</p><p><strong>采用字节码的好处：</strong><br>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h3 id="Java-和-C-的区别？"><a href="#Java-和-C-的区别？" class="headerlink" title="Java 和 C++ 的区别？"></a>Java 和 C++ 的区别？</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承，虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h3><p>1、接口的方法默认是 public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法<br>2、接口中的实例变量默认是 final 类型的， 而抽象类中则不定<br>3、一个类可以实现多个接口，但最多只能实现一个抽象类<br>4、一个类实现接口的话要实现接口的所有方法，而抽象类不一定<br>5、接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范<br><strong>注意：</strong>Java8 后接口可以有默认实现（default）。</p><h3 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h3><p>1、从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code> ,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及<code>static</code>所修饰；但是，成员变量和局部变量都能被<code>final</code>所修饰。<br>2、从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存。<br>3、从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。<br>4、成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被<code>final</code>修饰但没有被<code>static</code>修饰的成员变量必须显示地赋值），而局部变量则不会自动赋值。</p><h3 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h3><p><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　<br><strong>重写：</strong> 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为<code>private</code>则子类就不能重写该方法。</p><h3 id="字符型常量和字符串常量的区别？"><a href="#字符型常量和字符串常量的区别？" class="headerlink" title="字符型常量和字符串常量的区别？"></a>字符型常量和字符串常量的区别？</h3><p><strong>形式上:</strong><br>字符常量是单引号引起的一个字符<br>字符串常量是双引号引起的若干个字符<br><strong>含义上:</strong><br>字符常量相当于一个整形值(ASCII值),可以参加表达式运算<br>字符串常量代表一个地址值(该字符串在内存中存放位置)<br><strong>占内存大小</strong><br>字符常量只占一个字节<br>字符串常量占若干个字节(至少一个字符结束标志)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章回顾：&lt;a href=&quot;https://caozongpeng.github.io/2019/02/20/%E6%9C%80%E6%9C%80%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E4%B8%80/&quot;&gt;最最最常见的Java面试题总结(一)&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;images/java/java-logo.jpg&quot; alt=&quot;mysql&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://caozongpeng.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://caozongpeng.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>最最最常见的Java面试题总结(一)</title>
    <link href="https://caozongpeng.github.io/2019/02/20/%E6%9C%80%E6%9C%80%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E4%B8%80/"/>
    <id>https://caozongpeng.github.io/2019/02/20/最最最常见的Java面试题总结-一/</id>
    <published>2019-02-20T12:48:19.000Z</published>
    <updated>2019-02-20T14:18:34.389Z</updated>
    
    <content type="html"><![CDATA[<p>本文谈谈JAVA面试最常问问题。<br><img src="images/java/java-logo.jpg" alt="mysql"><br><a id="more"></a></p><h3 id="一、为什么JAVA中只有值传递？"><a href="#一、为什么JAVA中只有值传递？" class="headerlink" title="一、为什么JAVA中只有值传递？"></a>一、为什么JAVA中只有值传递？</h3><p>按值调用（call by value）表示方法接收的是调用者提供的值，而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p><h5 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure></p><p>在swap方法中，a、了的值进行交换，并不会影响到 num1、num2。因为 a、b中的值，只是从 num1、num2中复制过来的。也就是说 a、b相当于 num1、num2的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><strong> 通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样</strong>。</p><h5 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>array被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr指向的是同一个数组对象。因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>通过例二我们已经看到，实现一个改变对象参数状态的方法并不是一件难事，理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象</strong>。</p><h5 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">"李四"</span>);</span><br><span class="line">Test.swap(s1, s2);</span><br><span class="line">System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">Student temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:李四</span><br><span class="line">y:张三</span><br><span class="line">s1:张三</span><br><span class="line">s2:李四</span><br></pre></td></tr></table></figure></p><p>可以看出方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。<br>下面再总结一下Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h3 id="二、-与-equals-重要"><a href="#二、-与-equals-重要" class="headerlink" title="二、== 与 equals(重要)"></a>二、== 与 equals(重要)</h3><p><code>==</code>: 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。（基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址）</p><p><strong>equals()</strong>：它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖<code>equals()</code>方法。则通过equals()比较该类的两个对象时，等价于通过 <code>==</code> 比较两个对象。</li><li>情况2：类覆盖了<code>equals()</code>方法。一般，我们都覆盖 equals() 方法来判断两个对象的内容是否相等。若它们的内容相等，则返回true(即，认为这两个对象相等)。<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>说明：</strong></p><ul><li>String中的 <code>equals()</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals()</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals()</code> 方法比较的是对象的值。</li><li>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</li></ul><h3 id="三、hashCode-与-equals-重要"><a href="#三、hashCode-与-equals-重要" class="headerlink" title="三、hashCode 与 equals(重要)"></a>三、hashCode 与 equals(重要)</h3><p>面试官可能经常会问你：<strong>你重写过hashCode和equals方法么，为什么重写equals时必须重写hashCode方法？</strong></p><h4 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode() 介绍"></a>hashCode() 介绍</h4><p><code>hashCode()</code>的作用是获取哈希码，也称为散列码。它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在JDK的Object.java中，这就意味着Java中的任何类都包含有<code>hashCode()</code> 函数。另外需要注意的是：Object 的 <code>hashCode()</code> 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常来将对象的内存地址转换为整数之后返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">    * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">    * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">    * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">    * technique is not required by the</span></span><br><span class="line"><span class="comment">    * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>散列表存储的是键值对(key-value)，它的特点是：能根据 键 快速的检索出对应的值。这其中就利用到了散列码！(可以快速找到所需要的对象)</p><h4 id="为什么要有hashCode"><a href="#为什么要有hashCode" class="headerlink" title="为什么要有hashCode"></a>为什么要有hashCode</h4><p><strong>以 HashSet 如果检查重复为例子来说明为什么要有hashCode</strong><br>当你把对象加入 <code>HashSet</code> 时， <code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 的值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code>会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同， <code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals()</code> 的次数，相应就大大提高了执行速度。</p><h4 id="hashCode-与-equals-相关规定"><a href="#hashCode-与-equals-相关规定" class="headerlink" title="hashCode() 与 equals() 相关规定"></a>hashCode() 与 equals() 相关规定</h4><p>1、如果两个对象相等，则 <code>hashCode</code> 一定也是相同的<br>2、两个对象相等，对两个对象分别调用 <code>equals</code> 方法都返回 <code>true</code><br>3、两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的<br>4、因此，<code>equals</code> 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖<br>5、<code>hashCode()</code> 的默认行为是对堆上的对象产生独特值，如果没有重写 <code>hashCode()</code>，则该class的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)</p><h4 id="为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a>为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？</h4><p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关(所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>上面提到了 <code>HashSet</code> 如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 只是用来缩小查找成本。<br>参考：<br><a href="https://blog.csdn.net/zhzhao999/article/details/53449504" target="_blank" rel="noopener">https://blog.csdn.net/zhzhao999/article/details/53449504</a><br><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3324958.html</a><br><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3324958.html</a><br><a href="https://www.cnblogs.com/Eason-S/p/5524837.html" target="_blank" rel="noopener">https://www.cnblogs.com/Eason-S/p/5524837.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文谈谈JAVA面试最常问问题。&lt;br&gt;&lt;img src=&quot;images/java/java-logo.jpg&quot; alt=&quot;mysql&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://caozongpeng.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://caozongpeng.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>面试必问MySQL题目(下)</title>
    <link href="https://caozongpeng.github.io/2019/01/31/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AEMySQL%E9%A2%98%E7%9B%AE-%E4%B8%8B/"/>
    <id>https://caozongpeng.github.io/2019/01/31/面试必问MySQL题目-下/</id>
    <published>2019-01-31T14:15:53.000Z</published>
    <updated>2019-02-15T13:57:30.481Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章回顾：<a href="https://caozongpeng.github.io/2019/01/31/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AEMySQL%E9%A2%98%E7%9B%AE-%E4%B8%8A/">面试必问MySQL题目(上)</a><br><img src="images/mysql/mysql.jpg" alt="mysql"><br><a id="more"></a></p><h3 id="什么是数据库索引？索引有哪几种类型？什么是最左前缀原则？索引算法有哪些？有什么区别？"><a href="#什么是数据库索引？索引有哪几种类型？什么是最左前缀原则？索引算法有哪些？有什么区别？" class="headerlink" title="什么是数据库索引？索引有哪几种类型？什么是最左前缀原则？索引算法有哪些？有什么区别？"></a>什么是数据库索引？索引有哪几种类型？什么是最左前缀原则？索引算法有哪些？有什么区别？</h3><h4 id="关于数据库索引的内容可以参考我这篇文章："><a href="#关于数据库索引的内容可以参考我这篇文章：" class="headerlink" title="关于数据库索引的内容可以参考我这篇文章："></a>关于数据库索引的内容可以参考我这篇文章：</h4><p><a href="https://caozongpeng.github.io/2019/01/31/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AEMySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/">面试必问MySQL之索引</a></p><p>索引是对数据库表中一列或多列的值进行排序的一种结构。一个非常恰当的比喻就是书的目录页与书的正文内容之间的关系，为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p><h5 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h5><p>数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><h5 id="唯一索引："><a href="#唯一索引：" class="headerlink" title="唯一索引："></a>唯一索引：</h5><p>数据列不允许重复，允许为NULL值，一个表允许多个创建唯一索引。</p><p>可以通过<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建唯一索引</span><br><span class="line">ALERT TABLE table_name ADD UNIQUE(cloumn);</span><br><span class="line"></span><br><span class="line">创建唯一组合索引</span><br><span class="line">ALERT TABLE table_name ADD UNIQUE (column1,column2);</span><br></pre></td></tr></table></figure></p><h5 id="普通索引："><a href="#普通索引：" class="headerlink" title="普通索引："></a>普通索引：</h5><p>基本的索引类型，没有唯一性的限制，允许为NULL值。<br>可以通过<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建普通索引</span><br><span class="line">ALERT TABLE table_name ADD INDEX index_name (column);</span><br><span class="line"></span><br><span class="line">创建组合索引</span><br><span class="line">ALERT TABLE table_name ADD INDEX index_name(column1, column2,column3);</span><br></pre></td></tr></table></figure></p><h5 id="全文索引："><a href="#全文索引：" class="headerlink" title="全文索引："></a>全文索引：</h5><p>是目前搜索引擎使用的一种关键技术。<br>可以通过<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建全文索引</span><br><span class="line">ALERT TABLE table_name ADD FULLTEXT (column);</span><br></pre></td></tr></table></figure></p><h5 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h5><ul><li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，WHERE子句使用最频繁的一列放在最左边。</li><li>还有一个就是生效原则<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index(a,b,c)</span><br><span class="line">where a=3    只使用了a</span><br><span class="line">where a=3 and b=5    使用了a,b</span><br><span class="line">where a=3 and b=5 and c=4    使用了a,b,c</span><br><span class="line">where b=3 or where c=4    没有使用索引</span><br><span class="line">where a=3 and c=4    仅使用了a</span><br><span class="line">where a=3 and b&gt;10 and c=7    使用了a,b</span><br><span class="line">where a=3 and b like ' xx%' and c=7    使用了a,b</span><br></pre></td></tr></table></figure></li></ul><h3 id="索引算法有-BTree、-Hash"><a href="#索引算法有-BTree、-Hash" class="headerlink" title="索引算法有 BTree、 Hash"></a>索引算法有 <code>BTree</code>、 <code>Hash</code></h3><p>BTree是最常见用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在 =，&gt;，&gt;=，&lt;，&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开关的常量，例如：<code>SELECT * FROM user WHERE name LIKE &#39;java%&#39;;</code>如果一通配符开关，或者没有使用常量，则不会使用索引，例如：<code>SELECT * FROM user WHERE name LIKE &#39;%java&#39;;</code></p><h5 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h5><p>Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p><p>BTree索引是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符<br>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'jack%'</span>; </span><br><span class="line">如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%jack'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h3><p>1、适合索引的列是出现在where子句中的列，或者连接子句中指定的列。<br>2、基数较小的类，索引效果较差，没有必要在此列建立索引。<br>3、使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间。<br>4、不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p><h3 id="如何定位及SQL语句的性能问题？"><a href="#如何定位及SQL语句的性能问题？" class="headerlink" title="如何定位及SQL语句的性能问题？"></a>如何定位及SQL语句的性能问题？</h3><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划。<br>我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。<br>而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。<br><img src="../../../../images/mysql/sql.jpg" alt="mysql"><br>执行计划包含的信息</p><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>有一组数字组成。表示一个查询中各个子查询的执行顺序;</p><ul><li>id相同执行顺序由上至下。</li><li>id不同，id值越大优先级越高，越先被执行。</li><li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li></ul><h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>每个子查询的查询类型，一些常见的查询类型。<br>| id | select_type | description |<br>|–|–|–|<br>|1 |SIMPLE | 不包含任何子查询或<code>UNION</code>等查询<br>|2 |PRIMARY | 包含子查询最外层查询就显示为 <code>PRIMARY</code><br>|3 |SUBQUERY | 在<code>SELECT</code>或<code>WHERE</code>子句中包含的查询<br>|4 |DERIVED | FROM 字句中包含的查询<br>|5 |UNION | 出现在 UNION 后的查询语句中<br>|6 |UNION RESULT | 从 UNION中获取结果集，例如上文的第三个例子</p><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>查询的数据表，当从衍生表中查数据时会显示X表示对应的执行计划id。</p><h5 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h5><p>表分区、表创建的时候可以指定通过那个列进行表分区。</p><h5 id="type-非常重要，可以看到有没有走索引"><a href="#type-非常重要，可以看到有没有走索引" class="headerlink" title="type(非常重要，可以看到有没有走索引)"></a>type(非常重要，可以看到有没有走索引)</h5><ul><li>ALL 扫描全表数据</li><li>index 遍历索引</li><li>range 索引范围查找</li><li>index_subquery 在子查询中使用 ref</li><li>unique_subquery 在子查询中使用 eq_ref</li><li>ref_or_null 对Null进行索引的优化的 ref</li><li>fulltext 使用全文索引</li><li>ref 使用非唯一索引查找数据</li><li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联</li></ul><h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。<br>TIPS:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中。</p><h5 id="key-length"><a href="#key-length" class="headerlink" title="key_length"></a>key_length</h5><p>索引长度</p><h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p><h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>返回估算的结果集数目，并不是一个准确的值。</p><h5 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h5><p>extra的信息非常丰富，常见的有：<br>1、Using index 使用覆盖索引<br>2、Using where 使用了用where子句来过滤结果集<br>3、Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。<br>4、Using temporary 使用了临时表<br>sql优化的目标可以参考阿里开发手册<br><img src="../../../../images/mysql/alisql.jpg" alt="mysql"></p><h3 id="某个表有近千万数据，CRUD比较慢，如何优化？分为分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"><a href="#某个表有近千万数据，CRUD比较慢，如何优化？分为分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？" class="headerlink" title="某个表有近千万数据，CRUD比较慢，如何优化？分为分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"></a>某个表有近千万数据，CRUD比较慢，如何优化？分为分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3><p>数据千万级别之多，占用的存储空间也比较大，可想而知它不会存储在一块连续的物理空间上，而是链式存储在多个碎片的物理空间上。可能对于长字符串的比较，就用更多的时间查找与比较，这就导致用更多的时间。</p><ul><li>可以做表拆分，减少单表字段数量，优化表结构。</li><li>在保证主键有效的情况下，检查主键索引的字段顺序，使得查询语句中条件的字段顺序和主键索引的字段顺序保持一致。</li></ul><p>主要两种拆分，垂直拆分，水平拆分。<br><img src="../../../../images/mysql/split.jpg" alt="mysql"></p><h5 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h5><p>也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p><p>垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 切分后，要放在多个服务器上，而不是一个服务器上。为什么？ 我们想象一下，一个购物网站对外提供服务，会有用户，商品，订单等的CRUD。没拆分之前， 全部都是落到单一的库上的，这会让数据库的单库处理能力成为瓶颈。按垂直分库后，如果还是放在一个数据库服务器上， 随着用户量增大，这会让单个数据库的处理能力成为瓶颈，还有单个服务器的磁盘空间，内存，tps等非常吃紧。 所以我们要拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。</p><p>数据库业务层面的拆分，和服务的“治理”，“降级”机制类似，也能对不同业务的数据分别的进行管理，维护，监控，扩展等。 数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。 数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。</p><h5 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h5><p>针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。</p><h5 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h5><p>将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p><h5 id="水平分库分表切分规则"><a href="#水平分库分表切分规则" class="headerlink" title="水平分库分表切分规则"></a>水平分库分表切分规则</h5><p>1、<strong>RANGE划分</strong>：RANGE从0到10000一个表，10001到20000一个表；</p><p>2、<strong>HASH取模</strong>：一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。</p><p>3、<strong>地理区域</strong>：比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</p><p>4、<strong>时间</strong>：按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</p><h5 id="分库分表面临的问题"><a href="#分库分表面临的问题" class="headerlink" title="分库分表面临的问题"></a>分库分表面临的问题</h5><ul><li><p><strong>事务支持</strong><br>分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></li><li><p><strong>跨库JOIN</strong><br>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。</p></li><li><p><strong>跨节点的 COUNT,ORDER BY,GROUP BY以及聚合函数问题</strong><br>这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p></li><li><p><strong>数据迁移，容量规则，扩容等问题</strong><br>来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p></li><li><p><strong>ID问题</strong><br>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由。</p></li></ul><h5 id="一些常见的主键生成策略"><a href="#一些常见的主键生成策略" class="headerlink" title="一些常见的主键生成策略"></a>一些常见的主键生成策略</h5><p><strong>UUID</strong><br>使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。</p><p><strong>Twitter的分布式自增ID算法Snowflake</strong><br>在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p><p><strong>跨分片的排序分布</strong><br>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：<br><img src="../../../../images/mysql/page.jpg" alt="mysql"></p><p><strong>看间件推荐</strong><br><img src="../../../../images/mysql/middleware.jpg" alt="mysql"></p><h3 id="MySQL中in和exists区别"><a href="#MySQL中in和exists区别" class="headerlink" title="MySQL中in和exists区别"></a>MySQL中in和exists区别</h3><p>mysql中的<code>in</code>语句是把外表和内表作<code>hash</code> 连接，而<code>exists</code>语句是对外表作<code>loop</code>循环，每次<code>loop</code>循环再对内表进行查询。一直大家都认为<code>exists</code>比<code>in</code>语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><p>1、如果查询的两个表大小相当，那么用<code>in</code>和<code>exists</code>差别不大。<br>2、如果两个表中一个较小，一个是大表，则子查询大的用<code>exists</code>，子查询表小的用<code>in</code>。<br>3、<code>not in</code> 和 <code>not exists</code>如果查询语句使用了<code>not in</code> 那么内外表都进行全表扫描，没有用到索引;而<code>not exists</code>的子查询依然能用到表上的索引。所以无论那个表大，用 <code>not exists</code> 都比 <code>not in</code> 要快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章回顾：&lt;a href=&quot;https://caozongpeng.github.io/2019/01/31/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AEMySQL%E9%A2%98%E7%9B%AE-%E4%B8%8A/&quot;&gt;面试必问MySQL题目(上)&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;images/mysql/mysql.jpg&quot; alt=&quot;mysql&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库面试" scheme="https://caozongpeng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="MySQL" scheme="https://caozongpeng.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>面试必问MySQL题目(上)</title>
    <link href="https://caozongpeng.github.io/2019/01/31/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AEMySQL%E9%A2%98%E7%9B%AE-%E4%B8%8A/"/>
    <id>https://caozongpeng.github.io/2019/01/31/面试必问MySQL题目-上/</id>
    <published>2019-01-31T14:15:44.000Z</published>
    <updated>2019-02-19T15:24:03.032Z</updated>
    
    <content type="html"><![CDATA[<p>本文谈谈对数据库面试常问问题。<br><img src="images/mysql/mysql.jpg" alt="mysql"><br><a id="more"></a></p><h3 id="1、什么是数据库事务？如果没有事物会有什么后果？事务的特性是什么？"><a href="#1、什么是数据库事务？如果没有事物会有什么后果？事务的特性是什么？" class="headerlink" title="1、什么是数据库事务？如果没有事物会有什么后果？事务的特性是什么？"></a>1、什么是数据库事务？如果没有事物会有什么后果？事务的特性是什么？</h3><p>事务是指作为单个逻辑工作单元执行的一系列操作，可以被看作一个单元的一系列SQL语句的集合。要么完全地执行，要么完全地不执行。<br>如果不对数据库进行并发控制，可能会产生 <strong>脏读</strong>、<strong>非重复读</strong>、<strong>幻读</strong>、<strong>丢失修改</strong>的异常情况。</p><h4 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性(ACID)"></a>事务的四大特性(ACID)</h4><p>A、<strong>atomacity 原子性</strong> 事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。</p><p>C、<strong>consistency 一致性</strong> 事务将数据库从一种一致状态转变为下一种一致状态，也就是说，事务在完成时，必须使所有的数据都保持一致状态（各种constraint不被破坏）。</p><p>I、<strong>isolatioin 隔离性</strong> 由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。</p><p>D、<strong>durability 持久性</strong> 事务完成之后，它对于系统的影响是永久性的。该 修改即使出现致使的系统做障也将一直保持。</p><p>比如：</p><p>“A向B汇钱100”</p><p>1、读出A账号余额（500）。<br>2、A转出扣钱操作（500-100）。<br>3、结果写回A账号（400）。<br>4、读出B账号余额（500）。<br>5、B账号做加法操作（500+100）。<br>6、结果写回B账号（600）。</p><ul><li><p>原子性<br>保证 1-6所有过程要么都执行，要么都不执行。如果异常了那么回滚。</p></li><li><p>一致性<br>转账前，A和B账户中共有500+500=1000元钱。转账后，A和B的账户中共有400+600=1000元。</p></li><li><p>隔离性<br>在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱数量都不会有变化。</p></li><li><p>持久性<br>一旦转账成功（事务提交），两个账户里面的钱就会真的发生变化。</p></li></ul><h3 id="2、什么是脏读？幻读？不可重复读？什么是事务的隔离级别？MySQL的默认隔离级别是？"><a href="#2、什么是脏读？幻读？不可重复读？什么是事务的隔离级别？MySQL的默认隔离级别是？" class="headerlink" title="2、什么是脏读？幻读？不可重复读？什么是事务的隔离级别？MySQL的默认隔离级别是？"></a>2、什么是脏读？幻读？不可重复读？什么是事务的隔离级别？MySQL的默认隔离级别是？</h3><ul><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</li><li>不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li></ul><h5 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h5><p><strong>读未提交</strong>，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p><h5 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h5><p><strong>读提交</strong>，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p><p>比如：</p><p>小A去买东西（卡里有1万元），当他买单时（事务开启），系统事先检测到他的卡时有1万，就在这个时候！！小A的妻子要把钱全部转出充当家用，并提交，当系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。小A就会很崩溃，怎么突然钱不没了。</p><p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题，但在这个实例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p><h5 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h5><p><strong>重复读</strong>，就是在开始读取数据（事务开启）时，不再允许修改操作。</p><p>比如：</p><p>小A去买东西（卡里有1万元），当他买单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有1万，这时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p>分析：重复读可以解决不可重复读问题，写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题，因为幻读对应的是插入INSERT操作，而不是UPDATE操作。</p><p>什么时候会出现幻读？</p><p>比如：</p><p>小A去买东西，花了2千元，然后他的妻子去查看他的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，小A花了1万买了一部电脑，INSERT了一条水费记录，并提交。当妻子打印小A的水费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><h5 id="Serializable序列化"><a href="#Serializable序列化" class="headerlink" title="Serializable序列化"></a>Serializable序列化</h5><p><strong>Serializable</strong>是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可谓避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较消耗数据库性能，一般不使用。</p><p>MySQL的默认隔离级别是 <code>Repeatable read</code>，重复读。</p><h3 id="事物隔离是怎么实现的？有哪些锁？分别介绍下。"><a href="#事物隔离是怎么实现的？有哪些锁？分别介绍下。" class="headerlink" title="事物隔离是怎么实现的？有哪些锁？分别介绍下。"></a>事物隔离是怎么实现的？有哪些锁？分别介绍下。</h3><p>是基于锁实现的。</p><p>在DBMS中，可以按照锁的粒度把数据库锁分为行级锁（INNODB引擎）、表级锁（MYISAM引擎）和页级锁（BDB引擎）。</p><h5 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h5><p>行级锁是MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。<br><strong>特点</strong>：开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><h5 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h5><p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持，最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<br><strong>特点</strong>： 开销小，加锁快，不会出现死锁，锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><h5 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h5><p>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁，表级锁速度快，但冲突多，行级冲突少，但速度慢，所以取了折衷的页级，一次锁定相邻的一组记录。<br><strong>特点</strong>：开销和加锁时间介于表锁和行锁之间，会出现死锁，锁定粒度输球表锁和行锁之间，并发度一般。</p><h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对付的资源，从而导致恶性循环的现象。<br>常见的解决死锁的方法<br>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。<br>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。<br>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。<br>如果业务处理不好可以用分布式事务锁或者使用乐观锁。</p><h3 id="SQL的生命周期？关键字的先后顺序？"><a href="#SQL的生命周期？关键字的先后顺序？" class="headerlink" title="SQL的生命周期？关键字的先后顺序？"></a>SQL的生命周期？关键字的先后顺序？</h3><p>1、应用服务器与数据库服务器建立一个连接。<br>2、数据库进程拿到请求SQL。<br>3、解析并生成执行计划，执行。<br>4、读取数据到内存并进行逻辑处理。<br>5、通过步骤一的连接，发送结果到客户端。<br>6、关掉连接，释放资源。</p><p>1、 FROM：对 FROM 子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表 VT1。<br>2、 ON：对 VT1 应用 ON 筛选器，只有那些使为真才被插入到 TV2。<br>3、 OUTER (JOIN):如果指定了 OUTER JOIN(相对于 CROSS JOIN 或 INNER JOIN)，保留表中未找到<br>匹配的行将作为外部行添加到 VT2，生成 TV3。如果 FROM 子句包含两个以上的表，则对上一个联接生成的<br>结果表和下一个表重复执行步骤 1 到步骤 3，直到处理完所有的表位置。<br>4、 WHERE：对 TV3 应用 WHERE 筛选器，只有使为 true 的行才插入 TV4。<br>5、 GROUP BY：按 GROUP BY 子句中的列列表对 TV4 中的行进行分组，生成 TV5。<br>6、 CUTE|ROLLUP：把超组插入 VT5，生成 VT6。<br>7、 HAVING：对 VT6 应用 HAVING 筛选器，只有使为 true 的组插入到 VT7。<br>8、 SELECT：处理 SELECT 列表，产生 VT8。<br>9、 DISTINCT：将重复的行从 VT8 中删除，产品 VT9。<br>10、 ORDER BY：将 VT9 中的行按 ORDER BY 子句中的列列表顺序，生成一个游标(VC10)。<br>11、 TOP：从 VC10 的开始处选择指定数量或比例的行，生成表 TV11，并返回给调用者。</p><h3 id="什么是乐观锁？悲观锁？实现方式？"><a href="#什么是乐观锁？悲观锁？实现方式？" class="headerlink" title="什么是乐观锁？悲观锁？实现方式？"></a>什么是乐观锁？悲观锁？实现方式？</h3><p><strong>悲观锁</strong><br>悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或被坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力。自带的数据库事务就是典型的悲观锁。</p><p><strong>乐观锁</strong><br>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。<br>一般是加一个版本号字段每次更新时候比较版本号。</p><h3 id="什么是数据库连接池？"><a href="#什么是数据库连接池？" class="headerlink" title="什么是数据库连接池？"></a>什么是数据库连接池？</h3><p>从上一个SQL生命周期题目，可以看到其中的连接在里面发挥着重大作用，但频繁的创建和销毁，非常浪费系统资源。由于数据库更适合长连接，也就是有个连接池，能对连接复用，维护连接对象、分配、管理释放，也可以避免创建大量的连接对DB引发的各种问题。另外通过请求排除，也缓解DB的冲击。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文谈谈对数据库面试常问问题。&lt;br&gt;&lt;img src=&quot;images/mysql/mysql.jpg&quot; alt=&quot;mysql&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库面试" scheme="https://caozongpeng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="MySQL" scheme="https://caozongpeng.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>面试必问MySQL之索引</title>
    <link href="https://caozongpeng.github.io/2019/01/31/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AEMySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
    <id>https://caozongpeng.github.io/2019/01/31/面试必问MySQL之索引/</id>
    <published>2019-01-31T13:58:10.000Z</published>
    <updated>2019-02-20T12:42:49.175Z</updated>
    
    <content type="html"><![CDATA[<p>本文谈谈对数据库索引面试常问问题。<br><img src="images/mysql/mysql.jpg" alt="mysql"><br><a id="more"></a></p><h3 id="1、为什么使用索引？"><a href="#1、为什么使用索引？" class="headerlink" title="1、为什么使用索引？"></a>1、为什么使用索引？</h3><p>（1）通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>（2）可以大大回忆数据的检索速度（大大减少的检索的数据量），这也是创建索引的最主要的原因。<br>（3）帮助服务器避免排序和临时表。<br>（4）将随机IO变为顺序IO。<br>（5）可以加速表和表之间的连接，是在实现数据的参考完整性方面特别有意义。</p><h3 id="2、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"><a href="#2、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="2、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"></a>2、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h3><p>（1）当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。<br>（2）索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要那门聚簇索引，那么需要的空间就会更大。<br>（3）创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><h3 id="3、索引是如何提高查询速度的？"><a href="#3、索引是如何提高查询速度的？" class="headerlink" title="3、索引是如何提高查询速度的？"></a>3、索引是如何提高查询速度的？</h3><p>将无序的数据变成相对有序的数据（就像查目录一样）你说能不快吗？</p><h3 id="4、使用索引的注意事项。"><a href="#4、使用索引的注意事项。" class="headerlink" title="4、使用索引的注意事项。"></a>4、使用索引的注意事项。</h3><p>（1）在经常需要搜索的列上，可以回忆搜索的速度。<br>（2）在经常使用在<code>WHERE</code>子句中的列上而创建索引，加快条件的判断速度。<br>（3）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，回忆排序查询时间。<br>（4）对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引。<br>（5）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。<br>（6）避免<code>WHERE</code>子句中对字段施加函数，这会造成无法命中索引。<br>（7）在使用InnoDB时使用与业务无关的自增主键，即使用逻辑主键，而不要使用业务主键。<br>（8)将打算加索引的列设置为<code>NOT NULL</code>，否则将导致引擎放弃使用索引而进行全表扫描。<br>（9）删除长期未使用的索引，不用的索引存在会造成不必要的性能损耗<code>MySQL5.7</code>可以通过查询sys库的<code>chema_unused_indexes</code>视图查询哪些索引从未被使用<br>（10）在使用<code>LIMIT OFFSET</code>查询缓慢时，可以借助索引来提高性能。</p><h3 id="5、Mysql索引主要使用的两种数据结构。"><a href="#5、Mysql索引主要使用的两种数据结构。" class="headerlink" title="5、Mysql索引主要使用的两种数据结构。"></a>5、Mysql索引主要使用的两种数据结构。</h3><ul><li>哈希索引<br>对于紫苏红枣汤索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为音箱记录查询的时候，可以选择哈希索引，查询性能最快，其余大部分场景，建议选择BTree索引。</li><li>BTree索引<br>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎（<code>MyISAM</code>和<code>InnoDB</code>）的实现方式是不同的。<h3 id="6、MyISAM和InnoDB实现Btree索引方式的区别。"><a href="#6、MyISAM和InnoDB实现Btree索引方式的区别。" class="headerlink" title="6、MyISAM和InnoDB实现Btree索引方式的区别。"></a>6、MyISAM和InnoDB实现Btree索引方式的区别。</h3></li><li>MyISAM<br>B+Tree中节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为<strong>非聚簇索引</strong>。</li><li>InnoDB<br>其数据文件本身就是索引文件。相比<code>MyISAM</code>，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的灵气记录，这个索引的key是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。这被称为<strong>聚簇索引（或聚集索引）</strong>。而其作的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和<code>MyISAM</code>不同的地方，在根据主索引搜索时，直接找到key所在的节点即可取出数据，在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引，因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。<h3 id="7-覆盖索引介绍。"><a href="#7-覆盖索引介绍。" class="headerlink" title="7 覆盖索引介绍。"></a>7 覆盖索引介绍。</h3></li><li><p>什么是覆盖索引<br>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为<strong>覆盖索引</strong>，我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要回表，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。</p></li><li><p>现在我创建了索引（username，age），在查询数据的时候，<code>SELECT username,age FROM user WHERE username = &#39;java&#39; AND age = 22</code>。要查询出的列在叶子节点都存在！所以，就不用回表。</p></li></ul><h3 id="8、选择索引和编写利用这些索引的查询的3个原则。"><a href="#8、选择索引和编写利用这些索引的查询的3个原则。" class="headerlink" title="8、选择索引和编写利用这些索引的查询的3个原则。"></a>8、选择索引和编写利用这些索引的查询的3个原则。</h3><p>（1）单选访问是很慢的，特别是在机械硬盘存储中（SSD的随机I/O要快很多，不过这一点仍然成立），如果服务器从存储中读取一个数据快只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置索引，用以提升效率。<br>（2）按顺序访问范围数据是很快的，这有两个原因，第一，顺序I/O不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘），第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且<code>GROUP BY</code>查询也无须再做排序和将行按组进行聚合计算了。<br>（3）索引覆盖查询是很快的，如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行，这避免了大量的单选访问，而上面的第1点已经写明单行访问是很慢的。</p><h4 id="感谢阅读，写得不好的地方请指教"><a href="#感谢阅读，写得不好的地方请指教" class="headerlink" title="感谢阅读，写得不好的地方请指教"></a>感谢阅读，写得不好的地方请指教</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文谈谈对数据库索引面试常问问题。&lt;br&gt;&lt;img src=&quot;images/mysql/mysql.jpg&quot; alt=&quot;mysql&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库面试" scheme="https://caozongpeng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="MySQL" scheme="https://caozongpeng.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>常用MySQL优化</title>
    <link href="https://caozongpeng.github.io/2019/01/30/%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/"/>
    <id>https://caozongpeng.github.io/2019/01/30/常用MySQL优化/</id>
    <published>2019-01-30T13:49:59.000Z</published>
    <updated>2019-01-31T14:18:10.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文谈谈平时项目中常用的MySQL优化方法。</p></blockquote><p><img src="images/mysql/mysql.jpg" alt="mysql"><br><a id="more"></a></p><h3 id="1、SQL语句中IN包含的值不应过多"><a href="#1、SQL语句中IN包含的值不应过多" class="headerlink" title="1、SQL语句中IN包含的值不应过多"></a>1、SQL语句中<code>IN</code>包含的值不应过多</h3><p>MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。<br><strong>比如</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>对于这种连续的数值，能用<code>BETWEEN</code>就不要用<code>IN</code>，再或者使用连接来替换。</p><h3 id="2、SELECT语句务必指明字段名称"><a href="#2、SELECT语句务必指明字段名称" class="headerlink" title="2、SELECT语句务必指明字段名称"></a>2、<code>SELECT</code>语句务必指明字段名称</h3><p><code>SELECT *</code> 增加很多不必要的消耗(CPU、IO、内存、网络带宽)增加了使用覆盖索引的可能性，当表结构发生改变时，字段也需要更新。所以要求直接在<code>SELECT</code>后面接上字段名。</p><h3 id="3、当只需要一条数据的时候，使用-LIMIT-1"><a href="#3、当只需要一条数据的时候，使用-LIMIT-1" class="headerlink" title="3、当只需要一条数据的时候，使用 LIMIT 1"></a>3、当只需要一条数据的时候，使用 <code>LIMIT 1</code></h3><p>这是为了使用<code>EXPLAIN</code>中<code>type</code>列达到<code>const</code>类型</p><h3 id="4、如果排序字段没有用到索引，尽量少排序"><a href="#4、如果排序字段没有用到索引，尽量少排序" class="headerlink" title="4、如果排序字段没有用到索引，尽量少排序"></a>4、如果排序字段没有用到索引，尽量少排序</h3><h3 id="5、如果限制条件中其他字段没有索引，尽量少用-OR"><a href="#5、如果限制条件中其他字段没有索引，尽量少用-OR" class="headerlink" title="5、如果限制条件中其他字段没有索引，尽量少用 OR"></a>5、如果限制条件中其他字段没有索引，尽量少用 <code>OR</code></h3><p><code>OR</code>两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 <code>UNION ALL</code>或者是<code>UNION</code>（必要的时候）的方式来代替<code>OR</code>会得到更好的效果。</p><h3 id="6、尽量用-UNION-ALL-代替-UNION"><a href="#6、尽量用-UNION-ALL-代替-UNION" class="headerlink" title="6、尽量用 UNION ALL 代替 UNION"></a>6、尽量用 <code>UNION ALL</code> 代替 <code>UNION</code></h3><p><code>UNION</code>和<code>UNION ALL</code>的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，<code>UNION ALL</code>的前提条件是两个结果集没有重复数据。</p><h3 id="7、不使用-ORDER-BY-RAND"><a href="#7、不使用-ORDER-BY-RAND" class="headerlink" title="7、不使用 ORDER BY RAND()"></a>7、不使用 <code>ORDER BY RAND()</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_test <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">RAND</span>() <span class="keyword">LIMIT</span> <span class="number">1000</span>;</span><br><span class="line">优化为</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_test t1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">RAND</span>()* (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) t_test) <span class="keyword">AS</span> nid) t2 <span class="keyword">ON</span> t1.id &gt; t2.nid <span class="keyword">LIMIT</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><h3 id="8、区分-IN-和-EXISTS、NOT-IN-和-NOT-EXISTS"><a href="#8、区分-IN-和-EXISTS、NOT-IN-和-NOT-EXISTS" class="headerlink" title="8、区分 IN 和 EXISTS、NOT IN 和 NOT EXISTS"></a>8、区分 <code>IN</code> 和 <code>EXISTS</code>、<code>NOT IN</code> 和 <code>NOT EXISTS</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表A <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span>(<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> 表B)</span><br></pre></td></tr></table></figure><p>上面SQL语名相当于<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表B <span class="keyword">WHERE</span> 表B.id = 表A.id)</span><br></pre></td></tr></table></figure></p><p>区分 <code>IN</code> 和 <code>EXISTS</code> 主要是造成了驱动顺序的改变（这是性能变化的关键），如果是 <code>EXISTS</code>，那么以外层表为驱动表，先被访问，如果是 <code>IN</code> ，那么先执行子查询。所以 <code>IN</code> 适合于外表大而内表小的情况，<code>EXISTS</code> 适合于外表小而内表大的情况。</p><p>关于 <code>NOT IN</code> 和 <code>NOT EXISTS</code>，推荐使用 <code>NOT EXISTS</code>，不仅仅是效率问题，<code>NOT IN</code> 可能存在逻辑问题。</p><p>高效写出一个替代 NOT EXISTS 的SQL语句。</p><p>原SQL语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> colname.... <span class="keyword">FROM</span> 表A <span class="keyword">WHERE</span> a.id <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="keyword">SELECT</span> b.id <span class="keyword">FROM</span> 表B)</span><br></pre></td></tr></table></figure></p><p>优化SQL语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> colname.... <span class="keyword">FROM</span> 表A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> <span class="keyword">WHERE</span> a.id = b.id <span class="keyword">WHERE</span> b.id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p><p>表A不在表B中的数据</p><h3 id="9、使用合理的分布方式以提高分布的效率"><a href="#9、使用合理的分布方式以提高分布的效率" class="headerlink" title="9、使用合理的分布方式以提高分布的效率"></a>9、使用合理的分布方式以提高分布的效率</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age <span class="keyword">FROM</span> preson <span class="keyword">LIMIT</span> <span class="number">866331</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><p>使用上述SQL语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用<code>LIMIT</code>分页查询会越来越慢。</p><p>优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866331。SQL可以采用如下的写法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age <span class="keyword">FROM</span> preson <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">866331</span> <span class="keyword">LIMIT</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></p><h3 id="10、避免在-WHERE-子句中对字段进行-NULL-值判断"><a href="#10、避免在-WHERE-子句中对字段进行-NULL-值判断" class="headerlink" title="10、避免在 WHERE 子句中对字段进行 NULL 值判断"></a>10、避免在 <code>WHERE</code> 子句中对字段进行 <code>NULL</code> 值判断</h3><p>对于 <code>NULL</code> 的判断会导致引擎放弃使用索引而进行全表扫描。</p><h3 id="11、不建议使用-前缀模糊查询"><a href="#11、不建议使用-前缀模糊查询" class="headerlink" title="11、不建议使用 % 前缀模糊查询"></a>11、不建议使用 <code>%</code> 前缀模糊查询</h3><p>例如 <code>LIKE &quot;%name&quot;</code> 或者 <code>LIKE &quot;%name%&quot;</code>，这种查询会导致索引失效而进行全表扫描。但是可以使用 <code>LIKE &quot;name%&quot;</code>。</p><p>如何查询 <code>%name%</code></p><p>创建全文索引SQL语法<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`t_test`</span> <span class="keyword">ADD</span> FULLTEXT <span class="keyword">INDEX</span> <span class="string">`idx_user_name`</span>(<span class="string">`user_name`</span>);</span><br></pre></td></tr></table></figure></p><p>使用全文索引SQL语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(user_name) AGAINST(<span class="string">"张三"</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">mode</span>);</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：在需要创建全文索引之前，请联系DBA确定能否创建，同 时需要注意的是查询语句的写法与普通索引的区别。</p><h3 id="12、避免在-WHERE-子句中对字段进行表达式操作"><a href="#12、避免在-WHERE-子句中对字段进行表达式操作" class="headerlink" title="12、避免在 WHERE 子句中对字段进行表达式操作"></a>12、避免在 WHERE 子句中对字段进行表达式操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> age * <span class="number">22</span> = <span class="number">36</span>;</span><br></pre></td></tr></table></figure><p>对字段运行了算术运算，会造成引擎放弃使用索引，建议改成<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> age = <span class="number">36</span> / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><h3 id="13、避免隐匿类型转换"><a href="#13、避免隐匿类型转换" class="headerlink" title="13、避免隐匿类型转换"></a>13、避免隐匿类型转换</h3><p><code>WHERE</code> 子句中出现 <code>COLUMN</code> 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定<code>WHERE</code> 中的参数类型。</p><h3 id="14、对于联合索引来说，要遵守最左前缀法则。"><a href="#14、对于联合索引来说，要遵守最左前缀法则。" class="headerlink" title="14、对于联合索引来说，要遵守最左前缀法则。"></a>14、对于联合索引来说，要遵守最左前缀法则。</h3><p>举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面。</p><h3 id="15、必要时可以使用-FORCE-INDEX-来强制查询出某个索引"><a href="#15、必要时可以使用-FORCE-INDEX-来强制查询出某个索引" class="headerlink" title="15、必要时可以使用 FORCE INDEX 来强制查询出某个索引"></a>15、必要时可以使用 <code>FORCE INDEX</code> 来强制查询出某个索引</h3><p>有的时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用<code>FORCE INDEX</code>来强制优化器使用我们制定的索引。</p><h3 id="16、注意范围查询语句"><a href="#16、注意范围查询语句" class="headerlink" title="16、注意范围查询语句"></a>16、注意范围查询语句</h3><p>对于联合索引来说，如果存在范围查询，比如 <code>BETWEEN</code>、<code>&gt;</code> 、<code>&lt;</code> 等条件时，会造成后面的索引字段失效。</p><h3 id="17、关于-JOIN优化"><a href="#17、关于-JOIN优化" class="headerlink" title="17、关于 JOIN优化"></a>17、关于 <code>JOIN</code>优化</h3><p><code>LEFT JOIN</code> 以左边的表为驱动表，<code>INNER JOIN</code> 自动找出那个数据少的表作为驱动表，<code>RIGHT JOIN</code> 以右表为驱动表。</p><p>1、<strong>MySQL中淌有 <code>FULL JOIN</code>，可以用以下方式来解决</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">on</span> B.name = A.name <span class="keyword">WHERE</span> B.name <span class="keyword">is</span> <span class="literal">NULL</span> <span class="keyword">UNION</span> ALL <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> B;</span><br></pre></td></tr></table></figure></p><p>2、<strong>尽量使用 <code>INNER JOIN</code>，避免 <code>LEFT JOIN</code></strong><br>参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是<code>INNER JOIN</code>，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是<code>LEFT JOIN</code>在驱动表的选择上遵循的是左边驱动右边驱动的原则，即<code>LEFT JOIN</code>左边的表名为驱动表。<br>3、<strong>合理利用索引</strong><br>被驱动表的索引字段作为 ON 的限制字段。<br>4、<strong>利用小表去驱动多大表</strong><br>这样可以减少嵌套循环中的循环次数，以减少IO总量及CPU运算的次数。</p><p>5、<strong>巧用STRAIGHT_JOIN</strong><br><code>INNER JOIN</code>是由MySQL选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有<code>GROUP BY</code>、<code>ORDER BY</code>等<code>「Using filesort」</code>、<code>「Using temporary」</code>时。<code>STRAIGHT_JOIN</code>来强制连接顺序，在<code>STRAIGHT_JOIN</code>左边的表名就是驱动表，右边则是被驱动表。在使用<code>STRAIGHT_JOIN</code>有个前提条件是该查询是内连接，也就是<code>INNER JOIN</code>。其他链接不推荐使用<code>STRAIGHT_JOIN</code>，否则可能造成查询结果不准确。</p><h4 id="最后感谢阅读，写得不对的地方请指教。"><a href="#最后感谢阅读，写得不对的地方请指教。" class="headerlink" title="最后感谢阅读，写得不对的地方请指教。"></a>最后感谢阅读，写得不对的地方请指教。</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文谈谈平时项目中常用的MySQL优化方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/mysql/mysql.jpg&quot; alt=&quot;mysql&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://caozongpeng.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://caozongpeng.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JAVA代码性能优化总结</title>
    <link href="https://caozongpeng.github.io/2019/01/29/JAVA%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>https://caozongpeng.github.io/2019/01/29/JAVA代码性能优化总结/</id>
    <published>2019-01-29T14:29:25.000Z</published>
    <updated>2019-01-31T14:07:26.931Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>代码优化是很重要的，写出一手好代码是做为一名合格的程序员的前提，如果有足够的时间开发，维护代码，这时候就必须考虑每个可以优化的细节。一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。 </p></blockquote><h3 id="代码优化目标"><a href="#代码优化目标" class="headerlink" title="代码优化目标"></a>代码优化目标</h3><p>1、减少代码的体积<br>2、提高代码的运行的效率</p><p>本文内容有些来自网络，有些来自平时工作和学习。本文希望能帮助更多的同学。<br><a id="more"></a></p><h3 id="1、尽量指定类、方法的-final-修饰符"><a href="#1、尽量指定类、方法的-final-修饰符" class="headerlink" title="1、尽量指定类、方法的 final 修饰符"></a>1、尽量指定类、方法的 <code>final</code> 修饰符</h3><p>带有<code>final</code>修饰符的类是不可派生的。在Java核心API中，有许多应用<code>final</code>的例子，例如java.lang.String，整个类都是<code>final</code>的。为类指定<code>final</code>修饰符可以让类不可以被继承，为方法指定<code>final</code>修饰符可以让方法不可以被重写。如果指定了一个类为<code>final</code>，则该类所有的方法都是<code>final</code>的。Java编译器会寻找机会内联所有的<code>final</code>方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。</p><h3 id="2、尽量重用对象"><a href="#2、尽量重用对象" class="headerlink" title="2、尽量重用对象"></a>2、尽量重用对象</h3><p>特别是<code>String</code>对象的使用，出现字符串连接时应该使用<code>StringBuilder</code> 或 <code>StringBuffer</code>代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><h3 id="3、尽可能使用局部变量"><a href="#3、尽可能使用局部变量" class="headerlink" title="3、尽可能使用局部变量"></a>3、尽可能使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><h3 id="4、及时关闭流通"><a href="#4、及时关闭流通" class="headerlink" title="4、及时关闭流通"></a>4、及时关闭流通</h3><p>Java编程过程中，进行<strong>数据库连接</strong>、<strong>I/O流</strong>操作时务必小心，在使用完毕后，及时关闭以<strong>释放资源</strong>。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p><h3 id="5、尽量减少对变量的重复计算"><a href="#5、尽量减少对变量的重复计算" class="headerlink" title="5、尽量减少对变量的重复计算"></a>5、尽量减少对变量的重复计算</h3><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等,例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>建议替换为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">int</span> length = list.size(); i &lt; length; i++)&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>这样写，在list.size()很大的时候，就减少了很多的消耗。</p><h3 id="6、尽量采用懒加载的策略，即在需要的时候才创建"><a href="#6、尽量采用懒加载的策略，即在需要的时候才创建" class="headerlink" title="6、尽量采用懒加载的策略，即在需要的时候才创建"></a>6、尽量采用懒加载的策略，即在需要的时候才创建</h3><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"test"</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>建议替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    String str = <span class="string">"test"</span>;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、慎用异常"><a href="#7、慎用异常" class="headerlink" title="7、慎用异常"></a>7、慎用异常</h3><p>异常对性能不利。抛出异常首先要创建一个新的对象，<code>Throwable</code>接口的构造函数调用名为<code>fillInStackTrace()</code>的本地同步方法，<code>fillInStackTrace()</code>方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><h3 id="8、不要在循环中使用-try…catch…，应该把其放在最外层"><a href="#8、不要在循环中使用-try…catch…，应该把其放在最外层" class="headerlink" title="8、不要在循环中使用 try…catch…，应该把其放在最外层"></a>8、不要在循环中使用 try…catch…，应该把其放在最外层</h3><h3 id="9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度"><a href="#9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度" class="headerlink" title="9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度"></a>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</h3><p>比如ArrayList、LinkedList、StringBuilder、StringBuffer、HashMap、HashSet等。以StringBuilder为例<br>（1）StringBuilder()            // 默认分配16个字符的空间<br>（2）StringBuilder(int size)    // 默认分配size个字符的空间<br>（3）StringBuilder(String str)  // 默认分配16个字符+str.length()个字符空间</p><p>可以通过类（这里指的不仅仅是上面的<code>StringBuilder</code>）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如<code>StringBuilder</code>吧，length表示当前的<code>StringBuilder</code>能保持的字符数量。因为当<code>StringBuilder</code>达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要<code>StringBuilder</code>达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><p>1、在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间。</p><p>2、把原来的4096个字符拷贝到新的的字符数组中去。</p><p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p><h3 id="10、当复制大量数据时，使用-System-arraycopy-命令"><a href="#10、当复制大量数据时，使用-System-arraycopy-命令" class="headerlink" title="10、当复制大量数据时，使用 System.arraycopy()命令"></a>10、当复制大量数据时，使用 <code>System.arraycopy()</code>命令</h3><h3 id="11、乘法和除法使用移位操作"><a href="#11、乘法和除法使用移位操作" class="headerlink" title="11、乘法和除法使用移位操作"></a>11、乘法和除法使用移位操作</h3><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>) &#123;</span><br><span class="line">    a = val * <span class="number">8</span>;</span><br><span class="line">    b = val / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>) &#123;</span><br><span class="line">    a = val &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    b = val &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><h3 id="12、循环内不要不断创建对象引用"><a href="#12、循环内不要不断创建对象引用" class="headerlink" title="12、循环内不要不断创建对象引用"></a>12、循环内不要不断创建对象引用</h3><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p><h3 id="13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList"><a href="#13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList" class="headerlink" title="13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList"></a>13、基于效率和类型检查的考虑，应该尽可能使用<code>array</code>，无法确定数组大小时才使用<code>ArrayList</code></h3><h3 id="14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销"><a href="#14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销" class="headerlink" title="14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销"></a>14、尽量使用<code>HashMap</code>、<code>ArrayList</code>、<code>StringBuilder</code>，除非线程安全需要，否则不推荐使用<code>Hashtable</code>、<code>Vector</code>、<code>StringBuffer</code>，后三者由于使用同步机制而导致了性能开销</h3><h3 id="15、不要将数组声明为-public-static-final"><a href="#15、不要将数组声明为-public-static-final" class="headerlink" title="15、不要将数组声明为 public static final"></a>15、不要将数组声明为 <code>public static final</code></h3><p>因为这毫无意义，这样只是定义了引用为<code>static final</code>，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。</p><h3 id="16、尽量在合适的场合使用单例"><a href="#16、尽量在合适的场合使用单例" class="headerlink" title="16、尽量在合适的场合使用单例"></a>16、尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：<br>（1）控制资源的使用，通过线程同步来控制资源的并发访问。<br>（2）控制实例的产生，以达到节约资源的目的。<br>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p><h3 id="17、尽量避免随意使用静态变量"><a href="#17、尽量避免随意使用静态变量" class="headerlink" title="17、尽量避免随意使用静态变量"></a>17、尽量避免随意使用静态变量</h3><p>要知道，当某个对象被定义为<code>static</code>的变量所引用，那到<code>GC</code>通常是不会回收这个对象所占有的堆内存的。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止。</p><h3 id="18、及时清除不再需要的会话"><a href="#18、及时清除不再需要的会话" class="headerlink" title="18、及时清除不再需要的会话"></a>18、及时清除不再需要的会话</h3><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用<code>HttpSession</code>的<code>invalidate()</code>方法清除会话。</p><h3 id="19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历"><a href="#19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历" class="headerlink" title="19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历"></a>19、实现<code>RandomAccess</code>接口的集合比如<code>ArrayList</code>，应当使用最普通的<code>for</code>循环而不是<code>foreach</code>循环来遍历</h3><p>这是JDK推荐给用户的，JDK API对于<code>RandomAccess</code>接口的解释是：实现<code>RandomAccess</code>接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能，实际经验表明，实现<code>RandomAccess</code>接口的类实例，假如是随机访问的，使用普通<code>for</code>循环效率高于使用<code>foreach</code>循环，反过来，如果是顺序访问的，则使用Iterator会效率更高，可以使用为似如下的代码作判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        iterator.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>foreach</code>循环的底层实现原理就是迭代器<code>iterator</code>，参见Java语法糖1：可变长度参数以及<code>foreach</code>循环原理。所以后半句反过来，如果是顺序访问的，则使用<code>iterator</code>会效率更高的意思就是顺序访问的那些类实例，使用<code>foreach</code>循环去遍历。</p><h3 id="20、使用同步代码块替代同步方法"><a href="#20、使用同步代码块替代同步方法" class="headerlink" title="20、使用同步代码块替代同步方法"></a>20、使用同步代码块替代同步方法</h3><p>这点在多线程模块中的<code>synchronized</code>锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p><h3 id="21、将常量声明为-static-final-并以大写命名"><a href="#21、将常量声明为-static-final-并以大写命名" class="headerlink" title="21、将常量声明为 static final,并以大写命名"></a>21、将常量声明为 static final,并以大写命名</h3><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值，另外，将常量的名字以大写命名也可以方便分出常量与变量。</p><h3 id="22、不要创建一些不使用的对象，不要导入一些不使用的类"><a href="#22、不要创建一些不使用的对象，不要导入一些不使用的类" class="headerlink" title="22、不要创建一些不使用的对象，不要导入一些不使用的类"></a>22、不要创建一些不使用的对象，不要导入一些不使用的类</h3><p>这毫无意义，如果代码中出现 <strong>The value of the local variable i is not used</strong>、<strong>The import java.util is never used</strong>，那么请删除这些无用的内容。</p><h3 id="23、程序运行过程中避免使用反射"><a href="#23、程序运行过程中避免使用反射" class="headerlink" title="23、程序运行过程中避免使用反射"></a>23、程序运行过程中避免使用反射</h3><p>反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象放入内存，用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p><h3 id="24、使用数据库连接池和线程池"><a href="#24、使用数据库连接池和线程池" class="headerlink" title="24、使用数据库连接池和线程池"></a>24、使用数据库连接池和线程池</h3><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。</p><h3 id="25、使用带缓冲的输入输出流进行IO操作"><a href="#25、使用带缓冲的输入输出流进行IO操作" class="headerlink" title="25、使用带缓冲的输入输出流进行IO操作"></a>25、使用带缓冲的输入输出流进行IO操作</h3><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutPutStream，这可以极大地提升IO效率。</p><h3 id="26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList"><a href="#26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList" class="headerlink" title="26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList"></a>26、顺序插入和随机访问比较多的场景使用<code>ArrayList</code>，元素删除和中间插入比较多的场景使用<code>LinkedList</code></h3><p>这个需要理解ArrayList和LinkedList原理。</p><h3 id="27、不要让public方法中有太多的形参"><a href="#27、不要让public方法中有太多的形参" class="headerlink" title="27、不要让public方法中有太多的形参"></a>27、不要让public方法中有太多的形参</h3><p>public 方法即对外提供的方法，如果给这些方法大多形参的话主要有两点坏处：<br>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合。<br>2、参数太多势必导致方法调用的出错概率增加。</p><p>至于这个大多指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插入如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参，这样才符合Java面向对象的思想。</p><h3 id="28、字符串变量和字符串常量equals的时候将字符串常量写在前面"><a href="#28、字符串变量和字符串常量equals的时候将字符串常量写在前面" class="headerlink" title="28、字符串变量和字符串常量equals的时候将字符串常量写在前面"></a>28、字符串变量和字符串常量equals的时候将字符串常量写在前面</h3><p>这是一个比较觉的小技巧了，如果有以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Kyrie"</span></span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">"Kyrie"</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>建议修改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Kyrie"</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"Kyrie"</span>.equals(str))&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>这么做主要是可以避免空指针异常。</p><h3 id="29、请知道，在Java中if-i-1-和-if-1-i-是没有区别的，但从阅读习惯上讲，建议使用前者"><a href="#29、请知道，在Java中if-i-1-和-if-1-i-是没有区别的，但从阅读习惯上讲，建议使用前者" class="headerlink" title="29、请知道，在Java中if(i == 1) 和 if (1 == i) 是没有区别的，但从阅读习惯上讲，建议使用前者"></a>29、请知道，在Java中if(i == 1) 和 if (1 == i) 是没有区别的，但从阅读习惯上讲，建议使用前者</h3><p>“if (i == 1)”和”if (1 == i)”有没有区别，这就要从C/C++讲起。<br>在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C/C++判断”i == 1” 不成立，所以以0表示，即false。但是如果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (i = <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p><p>但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p><h3 id="30、不要对数组使用toString-方法"><a href="#30、不要对数组使用toString-方法" class="headerlink" title="30、不要对数组使用toString()方法"></a>30、不要对数组使用toString()方法</h3><p>看一下对数组使用toString()打印出来的是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I@<span class="number">18</span>a992f</span><br></pre></td></tr></table></figure></p><p>本意是想打印出数组的内容，却有可能因为数组引用i为空而导致空指针异常。不过虽然对数组<code>toString()</code>没有意义，但是对集合<code>toString()</code>是可以打印出集合里面的内容的，因为集合的父类<code>AbstractCollections&lt;E&gt;</code>重写了<code>Object</code>的<code>toString()</code>方法。</p><h3 id="32、不要对超出范围的基本数据类型做向下强制转型"><a href="#32、不要对超出范围的基本数据类型做向下强制转型" class="headerlink" title="32、不要对超出范围的基本数据类型做向下强制转型"></a>32、不要对超出范围的基本数据类型做向下强制转型</h3><p>方案绝不会得到想要的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">12345678901234L</span>;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)l;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可能期望得到其中的某几位，但是结果却是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1942892530</span><br></pre></td></tr></table></figure></p><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p><p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p><p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p><p>0111 0011 1100 1110 0010 1111 1111 0010</p><p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p><p>1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f”</p><p>2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int</p><h3 id="33、公用的集合类中不使用的数据一定要及时remove掉"><a href="#33、公用的集合类中不使用的数据一定要及时remove掉" class="headerlink" title="33、公用的集合类中不使用的数据一定要及时remove掉"></a>33、公用的集合类中不使用的数据一定要及时remove掉</h3><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄漏的隐患。</p><h3 id="34、把一个基本数据类型转为字符串，基本数据类型-toString-是最快的方式、String-valueOf-次之、数据-””最慢。"><a href="#34、把一个基本数据类型转为字符串，基本数据类型-toString-是最快的方式、String-valueOf-次之、数据-””最慢。" class="headerlink" title="34、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf()次之、数据+””最慢。"></a>34、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf()次之、数据+””最慢。</h3><p>把一个基本数据类型转为一般有三种方式，我有一个<code>Integer</code>型数据i，可以使用<code>i.toString()</code>、<code>String.valueOf(i)</code>、<code>i+&quot;&quot;</code>三种方式，三种方式的效率如何，看一个测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loopTime = <span class="number">50000</span>;</span><br><span class="line">    Integer i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)&#123;</span><br><span class="line">        String str = String.valueOf(i);</span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(<span class="string">"String.valueOf()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)&#123;</span><br><span class="line">        String str = i.toString();</span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(<span class="string">"Integer.toString()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)&#123;</span><br><span class="line">        String str = i + <span class="string">""</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(<span class="string">"i + "</span><span class="string">"："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运动结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf()：<span class="number">11</span>ms</span><br><span class="line">Integer.toString()：<span class="number">5</span>ms</span><br><span class="line">i + <span class="string">""</span>：<span class="number">25</span>ms</span><br></pre></td></tr></table></figure></p><p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单：</p><p>1、<code>String.valueOf()</code>方法底层调用了<code>Integer.toString()</code>方法，但是会在调用前做空判断。<br>2、<code>Integer.toString()</code>方法就不说了，直接调用了。<br>3、i + “”底层使用了<code>StringBuilder</code>实现，先用<code>append</code>方法拼接，再用<code>toString()</code>方法获取字符串。</p><p>三者对比下来，明显是2最快、1次之、3最慢。</p><h3 id="36、使用最有效率的方式去遍历Map"><a href="#36、使用最有效率的方式去遍历Map" class="headerlink" title="36、使用最有效率的方式去遍历Map"></a>36、使用最有效率的方式去遍历<code>Map</code></h3><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>,<span class="string">"Kyrie"</span>);</span><br><span class="line">    map.put(<span class="string">"age"</span>,<span class="string">"21"</span>);</span><br><span class="line">    Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String,String&gt; entry = iterator.next();</span><br><span class="line">        System.out.pringln(entry.getKey() + <span class="string">"==&gt;"</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你只是想遍历一下这个Map的key值，那用<strong>Set<string> keySet = map.keySet();</string></strong> 会比较合适一些</p><h3 id="36、对资源的close-建议分开操作"><a href="#36、对资源的close-建议分开操作" class="headerlink" title="36、对资源的close()建议分开操作"></a>36、对资源的close()建议分开操作</h3><p>比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    con.clone();</span><br><span class="line">    ds.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>建议修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    con.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ds.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然有些麻烦，即能避免资源泄漏。如果没有修改过的代码万一 con.clone()抛异常了，那么就进了了catch块中了，ds.clonse()不会执行，ds这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄漏的。而改为下面的写法之后，就保证了无论如何con和ds都会被close掉。</p><h4 id="感谢阅读，写得不好的地方请指教。"><a href="#感谢阅读，写得不好的地方请指教。" class="headerlink" title="感谢阅读，写得不好的地方请指教。"></a>感谢阅读，写得不好的地方请指教。</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;代码优化是很重要的，写出一手好代码是做为一名合格的程序员的前提，如果有足够的时间开发，维护代码，这时候就必须考虑每个可以优化的细节。一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;代码优化目标&quot;&gt;&lt;a href=&quot;#代码优化目标&quot; class=&quot;headerlink&quot; title=&quot;代码优化目标&quot;&gt;&lt;/a&gt;代码优化目标&lt;/h3&gt;&lt;p&gt;1、减少代码的体积&lt;br&gt;2、提高代码的运行的效率&lt;/p&gt;
&lt;p&gt;本文内容有些来自网络，有些来自平时工作和学习。本文希望能帮助更多的同学。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://caozongpeng.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://caozongpeng.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caozongpeng.github.io/2019/01/24/hello-world/"/>
    <id>https://caozongpeng.github.io/2019/01/24/hello-world/</id>
    <published>2019-01-24T05:04:02.000Z</published>
    <updated>2019-01-31T14:09:23.796Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post.</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post.&lt;/p&gt;
    
    </summary>
    
      <category term="测试" scheme="https://caozongpeng.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="https://caozongpeng.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
