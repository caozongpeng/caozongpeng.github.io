<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KyrieCao的个人网站</title>
  
  <subtitle>KyrieCao</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caozongpeng.github.io/"/>
  <updated>2019-01-29T15:08:48.444Z</updated>
  <id>https://caozongpeng.github.io/</id>
  
  <author>
    <name>KyrieCao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用MySQL优化</title>
    <link href="https://caozongpeng.github.io/2019/01/29/%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/"/>
    <id>https://caozongpeng.github.io/2019/01/29/常用MySQL优化/</id>
    <published>2019-01-29T13:49:59.000Z</published>
    <updated>2019-01-29T15:08:48.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文谈谈平时项目中常用的MySQL优化方法。</p></blockquote><p><img src="images/mysql/mysql.jpg" alt="mysql"><br><a id="more"></a></p><h3 id="1、SQL语句中IN包含的值不应过多"><a href="#1、SQL语句中IN包含的值不应过多" class="headerlink" title="1、SQL语句中IN包含的值不应过多"></a>1、SQL语句中<code>IN</code>包含的值不应过多</h3><p>MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。<br><strong>比如</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>对于这种连续的数值，能用<code>BETWEEN</code>就不要用<code>IN</code>，再或者使用连接来替换。</p><h3 id="2、SELECT语句务必指明字段名称"><a href="#2、SELECT语句务必指明字段名称" class="headerlink" title="2、SELECT语句务必指明字段名称"></a>2、<code>SELECT</code>语句务必指明字段名称</h3><p><code>SELECT *</code> 增加很多不必要的消耗(CPU、IO、内存、网络带宽)增加了使用覆盖索引的可能性，当表结构发生改变时，字段也需要更新。所以要求直接在<code>SELECT</code>后面接上字段名。</p><h3 id="3、当只需要一条数据的时候，使用-LIMIT-1"><a href="#3、当只需要一条数据的时候，使用-LIMIT-1" class="headerlink" title="3、当只需要一条数据的时候，使用 LIMIT 1"></a>3、当只需要一条数据的时候，使用 <code>LIMIT 1</code></h3><p>这是为了使用<code>EXPLAIN</code>中<code>type</code>列达到<code>const</code>类型</p><h3 id="4、如果排序字段没有用到索引，尽量少排序"><a href="#4、如果排序字段没有用到索引，尽量少排序" class="headerlink" title="4、如果排序字段没有用到索引，尽量少排序"></a>4、如果排序字段没有用到索引，尽量少排序</h3><h3 id="5、如果限制条件中其他字段没有索引，尽量少用-OR"><a href="#5、如果限制条件中其他字段没有索引，尽量少用-OR" class="headerlink" title="5、如果限制条件中其他字段没有索引，尽量少用 OR"></a>5、如果限制条件中其他字段没有索引，尽量少用 <code>OR</code></h3><p><code>OR</code>两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 <code>UNION ALL</code>或者是<code>UNION</code>（必要的时候）的方式来代替<code>OR</code>会得到更好的效果。</p><h3 id="6、尽量用-UNION-ALL-代替-UNION"><a href="#6、尽量用-UNION-ALL-代替-UNION" class="headerlink" title="6、尽量用 UNION ALL 代替 UNION"></a>6、尽量用 <code>UNION ALL</code> 代替 <code>UNION</code></h3><p><code>UNION</code>和<code>UNION ALL</code>的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，<code>UNION ALL</code>的前提条件是两个结果集没有重复数据。</p><h3 id="7、不使用-ORDER-BY-RAND"><a href="#7、不使用-ORDER-BY-RAND" class="headerlink" title="7、不使用 ORDER BY RAND()"></a>7、不使用 <code>ORDER BY RAND()</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_test <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">RAND</span>() <span class="keyword">LIMIT</span> <span class="number">1000</span>;</span><br><span class="line">优化为</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_test t1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">RAND</span>()* (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) t_test) <span class="keyword">AS</span> nid) t2 <span class="keyword">ON</span> t1.id &gt; t2.nid <span class="keyword">LIMIT</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><h3 id="8、区分-IN-和-EXISTS、NOT-IN-和-NOT-EXISTS"><a href="#8、区分-IN-和-EXISTS、NOT-IN-和-NOT-EXISTS" class="headerlink" title="8、区分 IN 和 EXISTS、NOT IN 和 NOT EXISTS"></a>8、区分 <code>IN</code> 和 <code>EXISTS</code>、<code>NOT IN</code> 和 <code>NOT EXISTS</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表A <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span>(<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> 表B)</span><br></pre></td></tr></table></figure><p>上面SQL语名相当于<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表B <span class="keyword">WHERE</span> 表B.id = 表A.id)</span><br></pre></td></tr></table></figure></p><p>区分 <code>IN</code> 和 <code>EXISTS</code> 主要是造成了驱动顺序的改变（这是性能变化的关键），如果是 <code>EXISTS</code>，那么以外层表为驱动表，先被访问，如果是 <code>IN</code> ，那么先执行子查询。所以 <code>IN</code> 适合于外表大而内表小的情况，<code>EXISTS</code> 适合于外表小而内表大的情况。</p><p>关于 <code>NOT IN</code> 和 <code>NOT EXISTS</code>，推荐使用 <code>NOT EXISTS</code>，不仅仅是效率问题，<code>NOT IN</code> 可能存在逻辑问题。</p><p>高效写出一个替代 NOT EXISTS 的SQL语句。</p><p>原SQL语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> colname.... <span class="keyword">FROM</span> 表A <span class="keyword">WHERE</span> a.id <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="keyword">SELECT</span> b.id <span class="keyword">FROM</span> 表B)</span><br></pre></td></tr></table></figure></p><p>优化SQL语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> colname.... <span class="keyword">FROM</span> 表A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表B <span class="keyword">ON</span> <span class="keyword">WHERE</span> a.id = b.id <span class="keyword">WHERE</span> b.id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p><p>表A不在表B中的数据</p><h3 id="9、使用合理的分布方式以提高分布的效率"><a href="#9、使用合理的分布方式以提高分布的效率" class="headerlink" title="9、使用合理的分布方式以提高分布的效率"></a>9、使用合理的分布方式以提高分布的效率</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age <span class="keyword">FROM</span> preson <span class="keyword">LIMIT</span> <span class="number">866331</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><p>使用上述SQL语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用<code>LIMIT</code>分页查询会越来越慢。</p><p>优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866331。SQL可以采用如下的写法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age <span class="keyword">FROM</span> preson <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">866331</span> <span class="keyword">LIMIT</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></p><h3 id="10、避免在-WHERE-子句中对字段进行-NULL-值判断"><a href="#10、避免在-WHERE-子句中对字段进行-NULL-值判断" class="headerlink" title="10、避免在 WHERE 子句中对字段进行 NULL 值判断"></a>10、避免在 <code>WHERE</code> 子句中对字段进行 <code>NULL</code> 值判断</h3><p>对于 <code>NULL</code> 的判断会导致引擎放弃使用索引而进行全表扫描。</p><h3 id="11、不建议使用-前缀模糊查询"><a href="#11、不建议使用-前缀模糊查询" class="headerlink" title="11、不建议使用 % 前缀模糊查询"></a>11、不建议使用 <code>%</code> 前缀模糊查询</h3><p>例如 <code>LIKE &quot;%name&quot;</code> 或者 <code>LIKE &quot;%name%&quot;</code>，这种查询会导致索引失效而进行全表扫描。但是可以使用 <code>LIKE &quot;name%&quot;</code>。</p><p>如何查询 <code>%name%</code></p><p>创建全文索引SQL语法<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`t_test`</span> <span class="keyword">ADD</span> FULLTEXT <span class="keyword">INDEX</span> <span class="string">`idx_user_name`</span>(<span class="string">`user_name`</span>);</span><br></pre></td></tr></table></figure></p><p>使用全文索引SQL语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(user_name) AGAINST(<span class="string">"张三"</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">mode</span>);</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：在需要创建全文索引之前，请联系DBA确定能否创建，同 时需要注意的是查询语句的写法与普通索引的区别。</p><h3 id="12、避免在-WHERE-子句中对字段进行表达式操作"><a href="#12、避免在-WHERE-子句中对字段进行表达式操作" class="headerlink" title="12、避免在 WHERE 子句中对字段进行表达式操作"></a>12、避免在 WHERE 子句中对字段进行表达式操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> age * <span class="number">22</span> = <span class="number">36</span>;</span><br></pre></td></tr></table></figure><p>对字段运行了算术运算，会造成引擎放弃使用索引，建议改成<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> age = <span class="number">36</span> / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><h3 id="13、避免隐匿类型转换"><a href="#13、避免隐匿类型转换" class="headerlink" title="13、避免隐匿类型转换"></a>13、避免隐匿类型转换</h3><p><code>WHERE</code> 子句中出现 <code>COLUMN</code> 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定<code>WHERE</code> 中的参数类型。</p><h3 id="14、对于联合索引来说，要遵守最左前缀法则。"><a href="#14、对于联合索引来说，要遵守最左前缀法则。" class="headerlink" title="14、对于联合索引来说，要遵守最左前缀法则。"></a>14、对于联合索引来说，要遵守最左前缀法则。</h3><p>举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面。</p><h3 id="15、必要时可以使用-FORCE-INDEX-来强制查询出某个索引"><a href="#15、必要时可以使用-FORCE-INDEX-来强制查询出某个索引" class="headerlink" title="15、必要时可以使用 FORCE INDEX 来强制查询出某个索引"></a>15、必要时可以使用 <code>FORCE INDEX</code> 来强制查询出某个索引</h3><p>有的时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用<code>FORCE INDEX</code>来强制优化器使用我们制定的索引。</p><h3 id="16、注意范围查询语句"><a href="#16、注意范围查询语句" class="headerlink" title="16、注意范围查询语句"></a>16、注意范围查询语句</h3><p>对于联合索引来说，如果存在范围查询，比如 <code>BETWEEN</code>、<code>&gt;</code> 、<code>&lt;</code> 等条件时，会造成后面的索引字段失效。</p><h3 id="17、关于-JOIN优化"><a href="#17、关于-JOIN优化" class="headerlink" title="17、关于 JOIN优化"></a>17、关于 <code>JOIN</code>优化</h3><p><code>LEFT JOIN</code> 以左边的表为驱动表，<code>INNER JOIN</code> 自动找出那个数据少的表作为驱动表，<code>RIGHT JOIN</code> 以右表为驱动表。</p><p>1、<strong>MySQL中淌有 <code>FULL JOIN</code>，可以用以下方式来解决</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">on</span> B.name = A.name <span class="keyword">WHERE</span> B.name <span class="keyword">is</span> <span class="literal">NULL</span> <span class="keyword">UNION</span> ALL <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> B;</span><br></pre></td></tr></table></figure></p><p>2、<strong>尽量使用 <code>INNER JOIN</code>，避免 <code>LEFT JOIN</code></strong><br>参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是<code>INNER JOIN</code>，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是<code>LEFT JOIN</code>在驱动表的选择上遵循的是左边驱动右边驱动的原则，即<code>LEFT JOIN</code>左边的表名为驱动表。<br>3、<strong>合理利用索引</strong><br>被驱动表的索引字段作为 ON 的限制字段。<br>4、<strong>利用小表去驱动多大表</strong><br>这样可以减少嵌套循环中的循环次数，以减少IO总量及CPU运算的次数。</p><p>5、<strong>巧用STRAIGHT_JOIN</strong><br><code>INNER JOIN</code>是由MySQL选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有<code>GROUP BY</code>、<code>ORDER BY</code>等<code>「Using filesort」</code>、<code>「Using temporary」</code>时。<code>STRAIGHT_JOIN</code>来强制连接顺序，在<code>STRAIGHT_JOIN</code>左边的表名就是驱动表，右边则是被驱动表。在使用<code>STRAIGHT_JOIN</code>有个前提条件是该查询是内连接，也就是<code>INNER JOIN</code>。其他链接不推荐使用<code>STRAIGHT_JOIN</code>，否则可能造成查询结果不准确。</p><h4 id="最后感谢阅读，写得不对的地方请指教。"><a href="#最后感谢阅读，写得不对的地方请指教。" class="headerlink" title="最后感谢阅读，写得不对的地方请指教。"></a>最后感谢阅读，写得不对的地方请指教。</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文谈谈平时项目中常用的MySQL优化方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/mysql/mysql.jpg&quot; alt=&quot;mysql&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://caozongpeng.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://caozongpeng.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caozongpeng.github.io/2019/01/24/hello-world/"/>
    <id>https://caozongpeng.github.io/2019/01/24/hello-world/</id>
    <published>2019-01-24T05:04:02.000Z</published>
    <updated>2019-01-29T13:54:10.470Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post.</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post.&lt;/p&gt;
    
    </summary>
    
      <category term="测试" scheme="https://caozongpeng.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="https://caozongpeng.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
